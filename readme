基于图论约束的软件架构设计想法


引言

在传统软件工程中，比如核心思想高内聚，低耦合，可读性，可拓展性之类，均是感性的主观描述。虽然是一门学科，但是它并不能提供一个统一的客观的标准。
也正是因此，它是经验化的，难以描述的。我们无法知道具体内聚到什么程度叫做低内聚。
所以本人在尝试寻找一个基于数学的方法，让数学替代纯粹的经验主义，通过计算，得到优秀的架构。

说明

这是一个软件架构设计想法。尚未经过全面验证和工程实践，仅供研究和讨论参考。

本文档尝试提出一个，基于图论构建的，通用的关系描述模式，从而在数学视角上，为软件工程中架构设计这一抽象且主观的工作，提供数学视角上的指导。

这不是一套“解释架构世界的理论”，
而是一套“用形式化方式约束设计空间的规则集”。

它会告诉你一个对象凭什么存在，究竟有什么因果。

在接受这些约束的前提下，它能显著提高架构的清晰度和可靠性。并且极大程度上消灭代码腐坏问题。

它不关注具体算法实现，只关注架构设计。但是它可以在宏观架构层面帮助你去简化并分析和处理内存安全，并发安全等问题。

它是一个面向高复杂度系统的形式化架构设计工具，它提供了一个框架，可以帮助架构师在理解并接受这些规则后，通过数学推导来设计出 健壮、可验证 的架构

它的表述可能比较晦涩，冗长，因为它只是为了记录而写的初稿。你可以将它交给ai解读，并让ai基于它的约束尝试多写一些代码。处理一些场景。您可以迅速理解它有什么用途。

它的使用对于架构师或程序员来说是需要一定门槛的,否则无法正确驾驭它。需要拥有明确的面向对象的架构思想和原子性功能划分的能力

它假设开发采用文档先行的模式


约束范围界定:

本规约约束的层面（What it governs）
本规约仅约束软件系统的静态架构结构，具体包括：
1 模块间依赖关系的性质
2 架构拓扑的结构属性
3 抽象层次的组织关系
4.它不关注具体算法实现 

通俗表述:

我们使用c语言编程来举一个例子，让它满足这个规约。首先为了便于分析，我们可以先在编码时对它进行一些约束。 
首先，我们强制面向对象。那么在c语言中，一个对象的定义就是，一个结构体和它的专用操作函数构成的集合。要求，每一个对象对外都是黑盒。  

然后我们来定义强依赖。如果一个对象内部嵌入了另一个对象本身，或者它的成员函数调用了另一个对象的操作函数，那么它就是强依赖。 
如果一个对象只持有了另一个对象的指针，比如只持有句柄。但是它不直接使用它(不使用它的操作函数,只负责存储指针)。那么它就是弱依赖。       

在整个架构中，所有的强依赖关系的集合构建出父子关系。比如a强依赖于b，那么b就是a的父亲。 
在以一个对象为中心的视角中，它的弱依赖对象一定是它的祖先，而强依赖必须是它的子孙。

这里要补充一点，在不同的对象为中心的上下文中，一个非中心对象要么是强依赖对象，要么是弱依赖对象，要么没有关系。  

我们可以通过父子关系构建图，所有的对象为节点，将所有强依赖关系为边。从而构建一个带有重边的有相图,要求任意两个节点间，所有边的方向必须相同。
 
此时我们可以以一个节点为中心，通过强弱依赖关系，提取一个子图，获取所有的对象节点，以及这些节点的父子关系的边。

补充:
此外这里还要进行一些补充防止误解，因为许多常见的程序执行并不是直观的面向对象，所以我们要对它进行拓扑:

1.首先，比如依赖注入，获取一个函数指针。那么我们分析时可以对函数指针看作强依赖关系，而持有函数指针的对象看作强依赖一个虚拟的对象。
被作为函数指针注入的对象可以独立分析，它依然是一个或多个节点的集合.
2.对于无明确对象操作的比如malloc，实际上和操作的是一个全局的对象句柄，所以和操作对应的对象完全等价。
3.对于像string sin一类无需传入对象的，可以看作它们拥有一个隐藏的叶子的无额外依赖的对象，调用了他们就是强依赖。


要求:
1.在这个子图中，所有的祖先节点必须相对于中心节点为弱依赖。而所有子孙节点必须相对于中心节点为强依赖
2.不得存在孤岛
3.任意一祖先节点到任意子孙节点必须可达

注意:
一个子可以有多个父
一个对象在不同上下文中会有不同身份。
身份是取决于参考系的,而非固定不变的，规约需要对所有的节点的以各自为中心的上下文都进行审查，必须保证所有的上下文中都满足规。

如何使用:
它并不是让你架构设计完成后再去验证。而是要在完全理解它后，基于它去执行架构的设计。

从没有依赖的叶子开始，增量化地构建系统。这或许非常抽象。
但是它会让你逐渐计算出一个健壮的架构。
让架构不是画出来，而是算出来。




二、 架构规约的数学形式化表述(这部分是让ai辅助生成的,可能不准确):
1. 基础定义

设软件架构为一个有向属性图 G=(M,E)，其中：

    模块集合 M：每个节点 m∈M 代表一个对象（结构体 + 函数集）。

    依赖边集 E⊆M×M×{s,w}：

        强依赖 (Strong)：记作 as​b，表示 b 是 a 的父节点 (Parent)。其物理意义为 a 嵌入了 b 或直接调用了 b 的函数。

        弱依赖 (Weak)：记作 aw​b，表示 b 是 a 的祖先引用 (Ancestor Reference)。其物理意义为 a 仅持有 b 的句柄且不直接操作。

2. 核心规约
2.1 规约一：强依赖的层级性 (层级偏序)

强依赖关系必须构成一个有向无环图 (DAG)。定义强依赖的传递闭包为 s+​：
∄a∈M 使得 as+​a

   架构意义：禁止任何形式的循环强耦合。

2.2 规约二：弱依赖的身份约束 (地位对等)

对于任何弱依赖关系 aw​b，b 在全局拓扑中必须是 a 的抽象祖先。即：
∀aw​b, 必存在路径 as+​b

    架构意义：你只能弱依赖你的“长辈”（已经在更高层级定义的模块）。禁止弱依赖你的子孙或平级模块，防止越权访问。

2.3 规约三：上下文子图构造 (Gx​)

对于任意核心模块 x∈M，其上下文依赖子图 Gx​=(Vx​,Ex​) 定义如下：

    子孙集 (Descendants)：D(x)={z∣xs+​z}

    祖先集 (Ancestors)：A(x)={y∣xw​y}

    节点集：Vx​={x}∪D(x)∪A(x)

    边集：Ex​ 为 Vx​ 在原图 G 中的所有诱导边。

2.4 规约四：上下文连通性与孤岛消除

在子图 Gx​ 中，必须满足：

    无孤岛：Gx​ 的弱连通分量数量为 1。

    可达性闭环：对于 x 的任意弱依赖祖先 y∈A(x)，必须存在至少一条路径能够到达 x 的任意强依赖子孙 z∈D(x)。
    ∀y∈A(x),∀z∈D(x):∃ Path(y⇝z)∈Gx​

    架构意义：确保高层抽象（祖先）下达的指令或持有的上下文，能够贯穿中心节点，最终落实到具体的执行单元（子孙）上。

2.5 规约五：依赖方向一致性

对于任意两个模块 a,b，其在所有包含它们的子图 Gxi​​ 中的依赖方向必须保持一致。
∀x,y∈M, 若 a,b∈Vx​∩Vy​, 则 Edge(a,b) 在 Gx​ 与 Gy​ 间依赖方向一致


基于范畴论的解释:
1. 对象与态射：构建架构范畴

首先，我们定义范畴 C：

    对象 (Objects): 集合 M 中的每一个模块（对象节点） m。

    态射 (Morphisms): 模块间的依赖关系。这里存在两种基础态射：

        强态射 f:a→b (对应强依赖 as​b)。

        弱态射 g:a⇢b (对应弱依赖 aw​b)。

2. 规约一与二：偏序集与伴随演算

规约 2.1 (DAG) 在范畴论中意味着这个范畴是一个薄范畴 (Thin Category)，其结构等价于一个偏序集 (Poset)。在这个范畴里，如果存在态射 a→b，就不可能存在反向态射 b→a。

规约 2.2 (弱依赖必为祖先) 的范畴论解释： 这定义了弱态射的存在性约束。设 S 是由强态射生成的子范畴。规约 2.2 要求：

    任何弱态射 w∈HomW​(a,b)，必须伴随一个在 S 子范畴中的复合强态射 s1​∘s2​∘...∘sn​:a→b。

这意味着弱依赖只是强依赖路径的一个“快捷方式”或“视图投影”。它不能引入原图中不存在的因果关系。
3. 规约三与四：拉回 (Pullback) 与 交换图表 (Commutative Diagram)

   上下文子图 Gx​ 的构造，实际上是在进行极限 (Limits) 的演算：

    Gx 的连通性： 在范畴论中，这意味着子图必须是一个连通范畴。

    可达性闭环 (y⇝z)： 这是一个典型的交换图表要求。 对于中心节点 x，如果存在态射 x⇢y（弱依赖祖先）和 x→z（强依赖子孙），规约要求必须存在一个从 y 到 z 的态射。

在范畴论中，这可以看作是要求节点 x 必须是一个余极限 (Colimit) 的一部分，或者它处在一个拉回 (Pullback) 结构中：

    祖先 y 提供的上下文（Context）与子孙 z 提供的执行（Execution），必须通过中心节点 x 实现逻辑上的对齐（Consistency）。

4. 规约五：函子性 (Functoriality)

规约 2.5 (方向一致性) 实际上是要求依赖关系在不同上下文切换时具有函子性 (Functorial property)。

不论你如何改变观察的中心（改变 Gx​ 到 Gy​），原本的态射方向必须保持不变。这意味着从全局范畴到局部子图的映射是一个忠实函子 (Faithful Functor)。它保证了局部观察到的结构永远不会背叛全局拓扑。





常见问题:
1.如果存在两个对象，假如是两台服务器相互收发信息，那么要怎么表述?
答:在两个对象间插入一个共有的父节点作为中心的数据交换的节点，它会负责被引用，以满足规约

2.依赖注入如何处理，如何架构设计

答:依赖注入分析时，先处理持有函数指针的节点，假设它强依赖于一个虚拟的节点。你可以将它看作一个没有依赖的节点而忽略它，或者引入会注入的依赖的共同依赖，从而执行上下文分析。
在完成这些节点框架的创建后，再去构建被注入的依赖。
你在构建依赖时，你会发现你依然还是遵守一样的原则进行分析。


3.对于中断路由之类如何处理
很明显还是和依赖注入是完全一致的

4.对于操作全局寄存器怎么处理
寄存器这类共享资源本身就是一个节点

5.它是否会影响性能
在本人的测试中大部分情况下它并不会带来严重的性能影响。
它会需要你去写更多代码，但是大部分情况下，编译器会为你优化它。
但是它不是万能的，它不代表一定性能最优。

5.总结:
如果遇到认为难以解释的架构，就说明它可能并不是很合适，
您需要转变思维方式，找到符合约束的功能相同的架构。这会很抽象，但是这也是它的难点。但是本人相信
一定有办法去找到一个符合规约的功能一致的表达形式。
当然你可以发现，它设计出来的架构自然就兼容了unix软件设计思想，rust所有权思想等，面向对象，结构编程等此外还有很多。




实践尝试:
为了证明它的有效，我这里使用它推导一些常见的重要规则:

1. 无循环依赖原则
text

从 A2 直接得出：
"系统中不允许存在循环依赖"

证明：A2规定强依赖必须构成DAG，DAG定义就是无环有向图。

工程意义：消除“改A要改B，改B要改C，改C要改A”的耦合噩梦。
2. 依赖倒置原则（Dependency Inversion Principle）
text

从 A3 直接得出：
"高层模块不应依赖低层模块，二者都应依赖抽象"

证明：A3要求弱依赖必须是祖先。在依赖DAG中，祖先位于拓扑序更前的位置，更稳定、更抽象。因此，模块只能依赖比它更抽象的事物。

形式化：
text

∀m∈M, ∀w∈WeakDeps(m): 
    ∃ path m →* w in StrongDeps  // w是m的祖先
    且 abstraction_level(w) ≥ abstraction_level(m)

3. 稳定抽象原则（Stable Abstraction Principle）
text

从 A3 + A2 推导出：
"一个模块的抽象程度应该与其稳定程度成正比"

证明：

    由A3：模块只能弱依赖祖先 → 祖先被更多模块依赖

    由A2：依赖是无环的 → 祖先在拓扑序中更靠前

    因此：祖先的修改会影响更多下游模块 → 祖先应该更稳定

    同时：祖先被作为抽象依赖 → 祖先应该更抽象

量化：模块的抽象度与其在DAG中的位置正相关。
三、间接推导出的重要原则
4. 单一责任原则（Single Responsibility Principle）
text

从 A4 推导出：
"一个模块应该有且只有一个改变的理由"

证明：

    A4要求：以模块x为中心的上下文子图G_x必须连通

    连通性意味着x的所有祖先和子孙在逻辑上相关

    如果x有两个不相关的责任R1和R2：

        R1对应一组依赖D1

        R2对应一组依赖D2

        D1和D2可能不连通 → 违反A4

    因此，为满足A4，x的责任必须内聚

更精确的表述：模块的责任是维护其上下文子图的连通性。
5. 接口隔离原则（Interface Segregation Principle）
text

从 A1 + A3 推导出：
"客户端不应被强迫依赖它们不用的接口"

证明：

    A1要求明确区分强依赖和弱依赖

    A3要求弱依赖必须是祖先（抽象）

    如果模块m弱依赖一个“肥胖接口”I，而m只使用I的部分功能：

        m实际上依赖了它不需要的功能

        当I的这些不需要部分变化时，m可能被意外影响

    根据A1精神（依赖关系应精确），应该：

        将I拆分为更精确的接口I1, I2...

        m只弱依赖它真正需要的部分

6. 里氏替换原则（Liskov Substitution Principle）
text

从 A5 推导出：
"子类型必须能够替换它们的父类型"

证明：

    A5要求依赖方向在所有上下文中一致

    假设有继承关系 Child : Parent

    如果Child不能完全替换Parent：

        在某些上下文中，Parent可接受

        在其他上下文中，Parent不可接受（需要检查具体类型）

        这意味着依赖关系不一致 → 违反A5

    因此，为满足A5，子类型必须完全可替换父类型

7. 开闭原则（Open-Closed Principle）
text

从 A3 + A4 推导出：
"软件实体应对扩展开放，对修改关闭"

证明：

    由A3：只能弱依赖祖先（抽象）

    由A4：上下文子图必须连通

    要添加新功能：

        可以创建新模块作为现有抽象的新实现（扩展）

        新模块成为现有模块的子孙

        现有模块的上下文子图仍然连通（满足A4）

        现有代码不需要修改（关闭修改）

形式化：
text

// 现有系统
Abstract A, Implementation A1, Client C
C --弱依赖--> A
A1 --强依赖--> A

// 扩展：添加A2
A2 --强依赖--> A
// C的上下文子图仍然连通，C不需要修改

四、推导出的架构模式
8. 分层架构模式
text

从 A2 + A3 推导出：
"系统应分为层次，每层只能依赖更低的层"

证明：

    由A2：强依赖构成DAG → 可拓扑排序得到层次

    由A3：弱依赖必须是祖先 → 依赖方向只能向下

    因此自然形成层次结构

层定义：同一拓扑深度的模块集合。
9. 依赖注入模式
text

从 A3 推导出：
"依赖应该从外部注入，而非在内部创建"

证明：

    A3要求弱依赖必须是祖先

    如果模块在内部创建依赖：
    text

// 违反A3的例子
class Service {
    Repository repo = new SqlRepository(); // 强依赖具体实现
}

正确做法：
text

class Service {
    Repository repo; // 弱依赖抽象
    Service(Repository r) { repo = r; } // 依赖注入
}

10. 面向接口编程
text

从 A3 直接得出：
"编程时应面向接口，而非实现"

证明：A3要求弱依赖必须是祖先（抽象）。因此所有跨模块的依赖都应通过接口/抽象进行。
五、推导出的工程实践
11. 编译顺序确定原则
text

从 A2 推导出：
"模块的编译顺序可由依赖关系确定"

证明：DAG可进行拓扑排序，排序结果就是合理的编译顺序。
12. 测试隔离原则
text

从 A3 + A4 推导出：
"模块应可独立测试"

证明：

    由A3：模块只弱依赖祖先（抽象）

    祖先可被替换为测试替身（Mock/Stub）

    由A4：模块的上下文子图连通

    在测试环境中，可用测试替身维持连通性

13. 增量构建原则
text

从 A2 + A4 推导出：
"系统可增量构建，先构建叶子，再逐步构建上层模块"

证明：

    A2确保依赖方向确定

    从叶子开始（无依赖的模块）

    逐步添加依赖已有模块的新模块

    A4确保每次添加后上下文仍然连通

六、推导出的质量属性
14. 可维护性定理
text

从 A2 + A3 + A4 推导出：
"系统的修改影响范围可预测且局部化"

证明：

    由A2：修改一个模块，只影响其子孙（下游）

    由A3：祖先被多模块依赖，但祖先更稳定，修改少

    由A4：每个修改可在模块的上下文子图内分析影响

量化：修改模块m的影响范围 ⊆ D(m) ∪ {m}
15. 可理解性定理
text

从 A4 推导出：
"每个模块的作用和边界清晰可理解"

证明：A4要求每个模块的上下文子图连通，这意味着：

    模块的输入源（祖先）明确

    模块的输出目标（子孙）明确

    模块在系统中的角色清晰

七、一个形式化推导示例

让我们用逻辑形式化地推导“无循环依赖”：
text

已知：A2: ∀a,b∈M, ¬(a →⁺ b ∧ b →⁺ a)  // 强依赖传递闭包无环

要证明：系统中不存在循环依赖

证明：
1. 假设存在循环依赖：a → b → c → ... → a
2. 根据依赖二分律(A1)，每个依赖或是强依赖(s)或是弱依赖(w)
3. 考虑两种情况：

情况1：循环中至少有一个强依赖
   设 a →ₛ b 在循环中
   则存在路径 b →* a （通过循环的其他部分）
   因此 a →ₛ⁺ a （因为→ₛ⁺包含传递闭包）
   这与A2矛盾

情况2：循环中全是弱依赖
   设 a →w b →w c →w ... →w a
   根据A3，弱依赖必须是祖先：b是a的祖先，c是b的祖先，...，a是...的祖先
   这意味着a是自己的祖先，这要求存在a →ₛ⁺ a
   再次与A2矛盾

4. 因此假设不成立，系统中不存在循环依赖。∎

八、SOLID原则的完整推导

现在让我们完整展示SOLID原则如何从五条规约推出：
text

S: 单一责任原则 ← A4（上下文连通律）
O: 开闭原则 ← A3 + A4（弱依赖祖先+上下文连通）
L: 里氏替换原则 ← A5（依赖方向绝对律）
I: 接口隔离原则 ← A1 + A3（依赖二分+弱依赖祖先）
D: 依赖倒置原则 ← A3（弱依赖祖先律）



16. 增量演化原则（Incremental Evolution Principle）
text

从 A2 + A4 推导出：
"系统可以通过一系列小的、保持正确性的步骤进行演化"

证明：

    A2确保依赖是DAG → 存在拓扑排序

    从叶子开始，每次添加一个新模块：

        新模块依赖已有模块（符合拓扑序）

        验证A4：新模块的上下文子图连通

        验证A3：弱依赖只指向祖先

    每一步都保持所有规约成立

工程意义：无需大规模重构，系统可渐进改进。




17. 正交性原则（Orthogonality Principle）
text

从 A4 推导出：
"系统中不相关的功能应该保持独立"

证明：

    假设两个不相关功能F1和F2共享模块M

    F1的依赖集D1，F2的依赖集D2，D1∩D2可能为空

    以M为中心的上下文子图可能不连通（D1和D2之间无路径）

    违反A4

    因此，不相关功能应该分离到不同模块


18. 显式依赖原则（Explicit Dependency Principle）
text

从 A1 + A5 推导出：
"所有依赖必须在架构中显式声明"

证明：

    A1要求所有依赖必须明确分类（强/弱）

    A5要求依赖方向在所有上下文中一致

    隐式依赖（如全局变量、单例）无法满足这些要求：

        无法明确分类

        在不同上下文中表现可能不一致


27. 最小权限原则（Principle of Least Privilege）
text

从 A3 推导出：
"模块只应拥有完成其功能所需的最小权限"

证明：

    A3要求只能弱依赖祖先

    祖先定义了模块能访问的能力集合

    如果模块弱依赖了不必要的祖先：

        它拥有不必要的权限

        可能被滥用

    因此，应该精确控制弱依赖集合

        
28. 安全边界清晰原则
text

从 A4 推导出：
"安全边界应该与模块上下文边界对齐"

证明：

    A4定义了每个模块的上下文子图

    这是自然的信任边界

    跨边界访问需要显式的授权检查


29. 错误隔离原则（Fault Isolation Principle）
text

从 A4 推导出：
"一个模块的失败不应该导致整个系统失败"

证明：

    A4确保每个模块的上下文子图是连通的但有限的

    如果一个模块失败：

        只影响其子孙模块

        祖先模块不受影响（它们是弱依赖）

    因此，失败被隔离在局部


降级能力原则（Graceful Degradation）
text

从 A3 + A4 推导出：
"系统应该能够在部分模块失效时继续提供降级服务"

证明：

    A3：模块通过弱依赖使用祖先服务

    如果某个祖先服务失效：

        依赖它的模块可能无法工作

        但不依赖它的其他模块仍可工作

    A4：每个模块有独立的上下文

    因此，可以设计系统使关键功能不依赖易失效模块


31.可追溯性原则（Traceability Principle）
text

从 A4 + A5 推导出：
"请求的处理路径应该可以跨模块追溯"

证明：

    A4确保模块间有连通路径

    A5确保依赖方向一致

    因此，一个请求可以从入口模块沿着依赖路径追溯

    这条路径是确定且一致的


32. 监控点布置原则
text

从 A4 推导出：
"监控点应该布置在模块上下文边界上"

证明：

    A4定义了模块的输入（祖先）和输出（子孙）

    在边界上监控可以：

        测量模块处理时间

        统计错误率

        跟踪数据流









免责声明

未经工业级的生产实践验证，请勿将此规约直接用于实际项目开发。

作者对使用此想法可能造成的任何损失或问题不承担责任。

欢迎讨论完善：此想法开放讨论，欢迎提出改进意见，但请注意这只是一个构思。

